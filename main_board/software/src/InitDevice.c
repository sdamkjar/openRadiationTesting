//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES


// USER PROTOTYPES
// USER FUNCTIONS

// $[Library includes]
#include "em_system.h"
#include "em_emu.h"
#include "em_cmu.h"
#include "em_device.h"
#include "em_chip.h"
#include "em_assert.h"
#include "em_burtc.h"
#include "em_rmu.h"
#include "em_gpio.h"
#include "em_i2c.h"
#include "em_usart.h"
#include "em_leuart.h"
#include "InitDevice.h"
#include "hal-config.h"
// [Library includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
	// $[Config Calls]
	LFXO_enter_DefaultMode_from_RESET();
	HFXO_enter_DefaultMode_from_RESET();
	CMU_enter_DefaultMode_from_RESET();
	UART0_enter_DefaultMode_from_RESET();
	UART1_enter_DefaultMode_from_RESET();
	LEUART0_enter_DefaultMode_from_RESET();
	LEUART1_enter_DefaultMode_from_RESET();
	USART0_enter_DefaultMode_from_RESET();
	USART1_enter_DefaultMode_from_RESET();
	USART2_enter_DefaultMode_from_RESET();
	USART3_enter_DefaultMode_from_RESET();
	USART4_enter_DefaultMode_from_RESET();
	I2C2_enter_DefaultMode_from_RESET();
	PORTIO_enter_DefaultMode_from_RESET();
	// [Config Calls]$

}

//================================================================================
// HFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void HFXO_enter_DefaultMode_from_RESET(void) {

	// $[HFXO]
	CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_DEFAULT;
	CMU_HFXOInit(&hfxoInit);
	CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_MODE_MASK) | CMU_HFXOCTRL_MODE_XTAL;
	SystemHFXOClockSet(50000000);
	// [HFXO]$

}

//================================================================================
// LFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void LFXO_enter_DefaultMode_from_RESET(void) {

	// $[Use oscillator source]
	CMU->LFXOCTRL = (CMU->LFXOCTRL & ~_CMU_LFXOCTRL_MODE_MASK) | CMU_LFXOCTRL_MODE_XTAL;
	// [Use oscillator source]$

	// $[LFXO Boost Percent]
	// [LFXO Boost Percent]$

	// $[REDLFXO Boost]
	// [REDLFXO Boost]$

}

//================================================================================
// CMU_enter_DefaultMode_from_RESET
//================================================================================
extern void CMU_enter_DefaultMode_from_RESET(void) {

	// $[LFXO enable]
	//CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
	// [LFXO enable]$

	// $[HFXO enable]
	CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
	// [HFXO enable]$

	// $[LFACLK Setup]
	// [LFACLK Setup]$

	// $[High Frequency Clock select]
	/* Using HFXO at 48MHz as high frequency clock, HFXO */
	//CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);

	//CMU_ClockDivSet(cmuClock_HFPER, cmuClkDiv_1);

	/* Enable peripheral clock */
	CMU_ClockEnable(cmuClock_HFPER, true);

	CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_HFCLKLE);
	CMU_ClockEnable(cmuClock_LFB, true);
	CMU_ClockEnable(cmuClock_CORELE, true);

	// [High Frequency Clock select]$

	// $[LF clock tree setup]
	/* No LF peripherals enabled */
	// [LF clock tree setup]$
	// $[Peripheral Clock enables]
	/* Enable clock for I2C2 */
	CMU_ClockEnable(cmuClock_I2C2, true);

	/* Enable clock for UART0 */
	CMU_ClockEnable(cmuClock_UART0, true);
//
	CMU_ClockEnable(cmuClock_UART1, true);

	CMU_ClockEnable(cmuClock_LEUART0, true);

	CMU_ClockEnable(cmuClock_LEUART1, true);

	CMU_ClockEnable(cmuClock_USART0, true);

	CMU_ClockEnable(cmuClock_USART1, true);

	CMU_ClockEnable(cmuClock_USART2, true);

	CMU_ClockEnable(cmuClock_USART3, true);

	CMU_ClockEnable(cmuClock_USART4, true);

	/* Enable LFE domain for RTCC */
	CMU_ClockEnable(cmuClock_CORELE, true);
	CMU_ClockSelectSet(cmuClock_LFE, cmuSelect_LFXO);

	/* Enable RTC clock */
	CMU_ClockEnable(cmuClock_RTCC, true);

	/* Enable clock for UART1 */
	//CMU_ClockEnable(cmuClock_UART1, true);

	/* Enable clock for USART0 */
	//CMU_ClockEnable(cmuClock_USART0, true);

	/* Enable clock for GPIO by default */
	CMU_ClockEnable(cmuClock_GPIO, true);



	// [Peripheral Clock enables]$

}

//================================================================================
// ADC0_enter_DefaultMode_from_RESET
//================================================================================
extern void ADC0_enter_DefaultMode_from_RESET(void) {

	// $[ADC_Init]
	// [ADC_Init]$

	// $[ADC_InitSingle]
	// [ADC_InitSingle]$

	// $[ADC_InitScan]
	// [ADC_InitScan]$

}

//================================================================================
// ACMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP0_enter_DefaultMode_from_RESET(void) {

	// $[ACMP Initialization]
	// [ACMP Initialization]$

	// $[ACMP Channel config]
	// [ACMP Channel config]$

}

//================================================================================
// ACMP1_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP1_enter_DefaultMode_from_RESET(void) {

	// $[ACMP Initialization]
	// [ACMP Initialization]$

	// $[ACMP Channel config]
	// [ACMP Channel config]$

}

//================================================================================
// DAC0_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC0_enter_DefaultMode_from_RESET(void) {

	// $[DAC Initialization]
	// [DAC Initialization]$

	// $[DAC Channel 0 config]
	// [DAC Channel 0 config]$

	// $[DAC Channel 1 config]
	// [DAC Channel 1 config]$

}

//================================================================================
// BURTC_enter_DefaultMode_from_RESET
//================================================================================
extern void BURTC_enter_DefaultMode_from_RESET(void) {

	// $[CMU_ClockEnable]
	// [CMU_ClockEnable]$

	// $[CMU_OscillatorEnable]
	// [CMU_OscillatorEnable]$

	// $[RMU_ResetControl]
	// [RMU_ResetControl]$

	// $[BURTC_Init]
	// [BURTC_Init]$

	// $[BURTC_CompareSet]
	// [BURTC_CompareSet]$

}

//================================================================================
// RTC_enter_DefaultMode_from_RESET
//================================================================================
extern void RTC_enter_DefaultMode_from_RESET(void) {

	// $[RTC_Init]
	// [RTC_Init]$

}

//================================================================================
// OPAMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP0_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// OPAMP1_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP1_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// OPAMP2_enter_DefaultMode_from_RESET
//================================================================================
extern void OPAMP2_enter_DefaultMode_from_RESET(void) {

	// $[DAC Output]
	// [DAC Output]$

	// $[OPAMP_Enable]
	// [OPAMP_Enable]$

}

//================================================================================
// USART0_enter_DefaultMode_from_RESET
//================================================================================
extern void USART0_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 250000;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART0, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART0, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// USART1_enter_DefaultMode_from_RESET
//================================================================================
extern void USART1_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 250000;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART1, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART1, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// USART2_enter_DefaultMode_from_RESET
//================================================================================
extern void USART2_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 250000;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART2, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART2, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// USART3_enter_DefaultMode_from_RESET
//================================================================================
extern void USART3_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 250000;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART3, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART3, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// USART4_enter_DefaultMode_from_RESET
//================================================================================
extern void USART4_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 921600;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(USART4, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(USART4, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// UART0_enter_DefaultMode_from_RESET
//================================================================================
extern void UART0_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 921600;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(UART0, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(UART0, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// UART1_enter_DefaultMode_from_RESET
//================================================================================
extern void UART1_enter_DefaultMode_from_RESET(void) {

	// $[UART_InitAsync]
	USART_InitAsync_TypeDef initasync = USART_INITASYNC_DEFAULT;

	initasync.baudrate = 921600;
	initasync.databits = usartDatabits8;
	initasync.parity = usartNoParity;
	initasync.stopbits = usartStopbits1;
	initasync.oversampling = usartOVS16;
#if defined( USART_INPUT_RXPRS ) && defined( USART_CTRL_MVDIS )
	initasync.mvdis = 0;
	initasync.prsRxEnable = 0;
	initasync.prsRxCh = 0;
#endif

	USART_InitAsync(UART1, &initasync);
	// [UART_InitAsync]$

	// $[USART_InitPrsTrigger]
	USART_PrsTriggerInit_TypeDef initprs = USART_INITPRSTRIGGER_DEFAULT;

	initprs.rxTriggerEnable = 0;
	initprs.txTriggerEnable = 0;
	initprs.prsTriggerChannel = usartPrsTriggerCh0;

	USART_InitPrsTrigger(UART1, &initprs);
	// [USART_InitPrsTrigger]$

}

//================================================================================
// LEUART0_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART0_enter_DefaultMode_from_RESET(void) {

	// $[LEUART0 initialization]
	LEUART_Init_TypeDef initleuart = LEUART_INIT_DEFAULT;
	LEUART_Reset(LEUART0);
	initleuart.refFreq = CMU_ClockFreqGet(cmuClock_LEUART0);
	initleuart.enable = leuartEnable;
	initleuart.baudrate = 921600;
	initleuart.databits = leuartDatabits8;
	initleuart.parity = leuartNoParity;
	initleuart.stopbits = leuartStopbits1;
	LEUART_Init(LEUART0, &initleuart);

	/* Configuring non-standard properties */
	LEUART_TxDmaInEM2Enable(LEUART0, 0);
	LEUART_RxDmaInEM2Enable(LEUART0, 0);
	// [LEUART0 initialization]$

}

//================================================================================
// LEUART1_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART1_enter_DefaultMode_from_RESET(void) {


	// $[LEUART1 initialization]
	LEUART_Init_TypeDef initleuart = LEUART_INIT_DEFAULT;
	LEUART_Reset(LEUART1);
	initleuart.refFreq = CMU_ClockFreqGet(cmuClock_LEUART1);
	initleuart.enable = leuartEnable;
	initleuart.baudrate = 921600;
	initleuart.databits = leuartDatabits8;
	initleuart.parity = leuartNoParity;
	initleuart.stopbits = leuartStopbits1;
	LEUART_Init(LEUART1, &initleuart);

	/* Configuring non-standard properties */
	LEUART_TxDmaInEM2Enable(LEUART1, 0);
	LEUART_RxDmaInEM2Enable(LEUART1, 0);
	// [LEUART1 initialization]$

}

//================================================================================
// VCMP_enter_DefaultMode_from_RESET
//================================================================================
extern void VCMP_enter_DefaultMode_from_RESET(void) {

	// $[VCMP_Init]
	// [VCMP_Init]$

}

//================================================================================
// WDOG_enter_DefaultMode_from_RESET
//================================================================================
extern void WDOG_enter_DefaultMode_from_RESET(void) {

	// $[CMU_ClockEnable]
	// [CMU_ClockEnable]$

	// $[CMU_OscillatorEnable]
	// [CMU_OscillatorEnable]$

	// $[WDOG_Init]
	// [WDOG_Init]$

}

//================================================================================
// I2C0_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C0_enter_DefaultMode_from_RESET(void) {

	// $[I2C0 initialization]
	I2C_Init_TypeDef init = I2C_INIT_DEFAULT;

	init.enable = 1;
	init.master = 1;
	init.freq = I2C_FREQ_FASTPLUS_MAX;
	init.clhr = i2cClockHLRStandard;
	I2C_Init(I2C0, &init);
	// [I2C0 initialization]$

}

//================================================================================
// I2C1_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C1_enter_DefaultMode_from_RESET(void) {

	// $[I2C1 initialization]
	I2C_Init_TypeDef init = I2C_INIT_DEFAULT;

	init.enable = 1;
	init.master = 1;
	init.freq = I2C_FREQ_STANDARD_MAX;
	init.clhr = i2cClockHLRStandard;
	I2C_Init(I2C1, &init);
	// [I2C1 initialization]$

}

//================================================================================
// I2C2_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C2_enter_DefaultMode_from_RESET(void) {

	// $[I2C2 initialization]
	I2C_Init_TypeDef init = I2C_INIT_DEFAULT;

	init.enable = 1;
	init.master = 1;
	init.freq = I2C_FREQ_STANDARD_MAX;
	init.clhr = i2cClockHLRStandard;
	I2C_Init(I2C2, &init);
	// [I2C2 initialization]$

}

//================================================================================
// TIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER0_enter_DefaultMode_from_RESET(void) {

	// $[TIMER0 initialization]
	// [TIMER0 initialization]$

	// $[TIMER0 CC0 init]
	// [TIMER0 CC0 init]$

	// $[TIMER0 CC1 init]
	// [TIMER0 CC1 init]$

	// $[TIMER0 CC2 init]
	// [TIMER0 CC2 init]$

	// $[TIMER0 DTI init]
	// [TIMER0 DTI init]$

}

//================================================================================
// TIMER1_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER1_enter_DefaultMode_from_RESET(void) {

	// $[TIMER1 initialization]
	// [TIMER1 initialization]$

	// $[TIMER1 CC0 init]
	// [TIMER1 CC0 init]$

	// $[TIMER1 CC1 init]
	// [TIMER1 CC1 init]$

	// $[TIMER1 CC2 init]
	// [TIMER1 CC2 init]$

}

//================================================================================
// TIMER2_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER2_enter_DefaultMode_from_RESET(void) {

	// $[TIMER2 initialization]
	// [TIMER2 initialization]$

	// $[TIMER2 CC0 init]
	// [TIMER2 CC0 init]$

	// $[TIMER2 CC1 init]
	// [TIMER2 CC1 init]$

	// $[TIMER2 CC2 init]
	// [TIMER2 CC2 init]$

}

//================================================================================
// TIMER3_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER3_enter_DefaultMode_from_RESET(void) {

	// $[TIMER3 initialization]
	// [TIMER3 initialization]$

	// $[TIMER3 CC0 init]
	// [TIMER3 CC0 init]$

	// $[TIMER3 CC1 init]
	// [TIMER3 CC1 init]$

	// $[TIMER3 CC2 init]
	// [TIMER3 CC2 init]$

}

//================================================================================
// LETIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void LETIMER0_enter_DefaultMode_from_RESET(void) {

	// $[LETIMER0_Init]
	// [LETIMER0_Init]$

}

//================================================================================
// PCNT0_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT0_enter_DefaultMode_from_RESET(void) {

	// $[PCNT0 initialization]
	// [PCNT0 initialization]$

}

//================================================================================
// PCNT1_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT1_enter_DefaultMode_from_RESET(void) {

	// $[PCNT1 initialization]
	// [PCNT1 initialization]$

}

//================================================================================
// PCNT2_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT2_enter_DefaultMode_from_RESET(void) {

	// $[PCNT2 initialization]
	// [PCNT2 initialization]$

}

//================================================================================
// PRS_enter_DefaultMode_from_RESET
//================================================================================
extern void PRS_enter_DefaultMode_from_RESET(void) {

	// $[PRS initialization]
	// [PRS initialization]$

}

//================================================================================
// ETM_enter_DefaultMode_from_RESET
//================================================================================
extern void ETM_enter_DefaultMode_from_RESET(void) {

	// $[ETM initialization]
	// [ETM initialization]$

}

//================================================================================
// EBI_enter_DefaultMode_from_RESET
//================================================================================
extern void EBI_enter_DefaultMode_from_RESET(void) {

	// $[EBI initialization]
	// [EBI initialization]$

}

//================================================================================
// PORTIO_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTIO_enter_DefaultMode_from_RESET(void) {

	GPIO_PinModeSet(PORTIO_I2C2_SDA_PORT, PORTIO_I2C2_SDA_PIN, gpioModeWiredAndPullUpFilter, 1);
	GPIO_PinModeSet(PORTIO_I2C2_SCL_PORT, PORTIO_I2C2_SCL_PIN, gpioModeWiredAndPullUpFilter, 1);

	GPIO_PinModeSet(PORTIO_LEUART0_TX_PORT, PORTIO_LEUART0_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_LEUART0_RX_PORT, PORTIO_LEUART0_RX_PIN, gpioModeInput, 0);

	GPIO_PinModeSet(PORTIO_LEUART1_TX_PORT, PORTIO_LEUART1_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_LEUART1_RX_PORT, PORTIO_LEUART1_RX_PIN, gpioModeInput, 0);

	GPIO_PinModeSet(PORTIO_UART0_TX_PORT, PORTIO_UART0_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_UART0_RX_PORT, PORTIO_UART0_RX_PIN, gpioModeInput, 0);

	GPIO_PinModeSet(PORTIO_UART1_TX_PORT, PORTIO_UART1_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_UART1_RX_PORT, PORTIO_UART1_RX_PIN, gpioModeInput, 0);

	GPIO_PinModeSet(PORTIO_USART0_TX_PORT, PORTIO_USART0_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_USART0_RX_PORT, PORTIO_USART0_RX_PIN, gpioModeInputPull, 1);

	GPIO_PinModeSet(PORTIO_USART1_TX_PORT, PORTIO_USART1_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_USART1_RX_PORT, PORTIO_USART1_RX_PIN, gpioModeInputPull, 1);

	GPIO_PinModeSet(PORTIO_USART2_TX_PORT, PORTIO_USART2_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_USART2_RX_PORT, PORTIO_USART2_RX_PIN, gpioModeInputPull, 1);

	GPIO_PinModeSet(PORTIO_USART3_TX_PORT, PORTIO_USART3_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_USART3_RX_PORT, PORTIO_USART3_RX_PIN, gpioModeInputPull, 1);

	GPIO_PinModeSet(PORTIO_USART4_TX_PORT, PORTIO_USART4_TX_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_USART4_RX_PORT, PORTIO_USART4_RX_PIN, gpioModeInput, 0);

	GPIO_PinModeSet(PORTIO_SENS_EN_PORT, PORTIO_SENS_EN_PIN, gpioModePushPull, 1);

	GPIO_PinModeSet(PORTIO_STP_EN_PORT, PORTIO_STP_EN_PIN, gpioModePushPull, 1);
	GPIO_PinModeSet(PORTIO_STP_DIR_PORT, PORTIO_STP_DIR_PIN, gpioModePushPull, 0);
	GPIO_PinModeSet(PORTIO_STP_STEP_PORT, PORTIO_STP_STEP_PIN, gpioModePushPull, 0);
	GPIO_PinModeSet(PORTIO_STP_MS1_PORT, PORTIO_STP_MS1_PIN, gpioModePushPull, 0);
	GPIO_PinModeSet(PORTIO_STP_MS2_PORT, PORTIO_STP_MS2_PIN, gpioModePushPull, 0);

	GPIO_PinModeSet(PORTIO_LED_PORT, PORTIO_LED_PIN, gpioModePushPull, 0);


	/* Module I2C1 */
	I2C2->ROUTEPEN = I2C_ROUTEPEN_SCLPEN | I2C_ROUTEPEN_SDAPEN ;

	I2C2->ROUTELOC0 = ( I2C2->ROUTELOC0 & ~( _I2C_ROUTELOC0_SCLLOC_MASK | _I2C_ROUTELOC0_SDALOC_MASK)) |
	( PORTIO_I2C2_SCL_LOC << _I2C_ROUTELOC0_SCLLOC_SHIFT ) | ( PORTIO_I2C2_SDA_LOC << _I2C_ROUTELOC0_SDALOC_SHIFT );

	/* Module UART0 */
	UART0->ROUTEPEN = UART_ROUTEPEN_RXPEN  | UART_ROUTEPEN_TXPEN;

	UART0->ROUTELOC0 = ( UART0->ROUTELOC0 & ~( _UART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_UART0_TX_LOC << _UART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_UART0_RX_LOC << _UART_ROUTELOC0_RXLOC_SHIFT );

	/* Module UART1 */
	UART1->ROUTEPEN = UART_ROUTEPEN_RXPEN  | UART_ROUTEPEN_TXPEN;

	UART1->ROUTELOC0 = ( UART1->ROUTELOC0 & ~( _UART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_UART1_TX_LOC << _UART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_UART1_RX_LOC << _UART_ROUTELOC0_RXLOC_SHIFT );

	/* Module LEUART0 */
	LEUART0->ROUTEPEN = LEUART_ROUTEPEN_RXPEN  | LEUART_ROUTEPEN_TXPEN;

	LEUART0->ROUTELOC0 = ( LEUART0->ROUTELOC0 & ~( _LEUART_ROUTELOC0_TXLOC_MASK | _LEUART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_LEUART0_TX_LOC << _LEUART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_LEUART0_RX_LOC << _LEUART_ROUTELOC0_RXLOC_SHIFT );

	/* Module LEUART1 */
	LEUART1->ROUTEPEN = LEUART_ROUTEPEN_RXPEN  | LEUART_ROUTEPEN_TXPEN;

	LEUART1->ROUTELOC0 = ( LEUART1->ROUTELOC0 & ~( _LEUART_ROUTELOC0_TXLOC_MASK | _LEUART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_LEUART1_TX_LOC << _LEUART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_LEUART1_RX_LOC << _LEUART_ROUTELOC0_RXLOC_SHIFT );

	/* Module USART0 */
	USART0->ROUTEPEN = USART_ROUTEPEN_RXPEN  | USART_ROUTEPEN_TXPEN;

	USART0->ROUTELOC0 = ( USART0->ROUTELOC0 & ~( _USART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_USART0_TX_LOC << _USART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_USART0_RX_LOC << _USART_ROUTELOC0_RXLOC_SHIFT );

	/* Module USART1 */
	USART1->ROUTEPEN = USART_ROUTEPEN_RXPEN  | USART_ROUTEPEN_TXPEN;

	USART1->ROUTELOC0 = ( USART1->ROUTELOC0 & ~( _USART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_USART1_TX_LOC << _USART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_USART1_RX_LOC << _USART_ROUTELOC0_RXLOC_SHIFT );

	/* Module USART2 */
	USART2->ROUTEPEN = USART_ROUTEPEN_RXPEN  | USART_ROUTEPEN_TXPEN;

	USART2->ROUTELOC0 = ( USART2->ROUTELOC0 & ~( _USART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_USART2_TX_LOC << _USART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_USART2_RX_LOC << _USART_ROUTELOC0_RXLOC_SHIFT );

	/* Module USART3 */
	USART3->ROUTEPEN = USART_ROUTEPEN_RXPEN  | USART_ROUTEPEN_TXPEN;

	USART3->ROUTELOC0 = ( USART3->ROUTELOC0 & ~( _USART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_USART3_TX_LOC << _USART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_USART3_RX_LOC << _USART_ROUTELOC0_RXLOC_SHIFT );

	/* Module USART4 */
	USART4->ROUTEPEN = USART_ROUTEPEN_RXPEN  | USART_ROUTEPEN_TXPEN;

	USART4->ROUTELOC0 = ( USART4->ROUTELOC0 & ~( _USART_ROUTELOC0_TXLOC_MASK | _USART_ROUTELOC0_RXLOC_MASK ) ) |
	( PORTIO_USART4_TX_LOC << _USART_ROUTELOC0_TXLOC_SHIFT ) | ( PORTIO_USART4_RX_LOC << _USART_ROUTELOC0_RXLOC_SHIFT );

//
//	/* Module UART1 is configured to location 3 */
//	UART1->ROUTE = (UART1->ROUTE & ~_UART_ROUTE_LOCATION_MASK)
//			| UART_ROUTE_LOCATION_LOC3;
//
//	/* Enable signals RX, TX */
//	UART1->ROUTE |= UART_ROUTE_RXPEN | UART_ROUTE_TXPEN;
//
//	/* Enable signals CLK, CS, RX, TX */
//	USART0->ROUTE |= USART_ROUTE_CLKPEN | USART_ROUTE_CSPEN | USART_ROUTE_RXPEN
//			| USART_ROUTE_TXPEN;
//	// [Route Configuration]$

}

